# 数据结果与算法

出处：https://subingwen.cn/data-structure/

# 1、数据结构和算法

## 1.1 概述

### 1.1.1 概念

数据结构和算法是计算机科学中的一组重要概念。先看一下官方对这两个概念的定义：

- **数据结构**：是相互之间存在一种或多种特定关系的数据元素的集合。
- **算法**：是指解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个步骤。

为了方便理解，上述概念可以再说的直白一些：

- 数据结构就是指一组数据的存储方式
- 算法就是操作数据的一组方法

### 1.1.2 为什么要学习数据结构和算法

为什么要学习数据结构和算法呢?

1. 想要通关大厂面试，千万别让数据结构和算法拖了后腿
2. 业务开发工程师，不能做一辈子 CRUD（增删改查）
3. 基础架构研发工程师，写出达到开源水平的框架才是目标
4. 对编程还有追求？不想被行业淘汰？那就不要只会写凑合能用的代码

学习数据结构具有多重好处：

1. **提高问题解决能力：** 数据结构是组织和存储数据的方式，学习数据结构可以帮助你更好地理解问题的本质，并能够有效地设计和实现解决方案。
2. **提升编程能力：** 数据结构是编程的基础，掌握了数据结构可以让你写出更高效、更健壮的代码，提升编程技能和代码质量。
3. **优化算法效率：** 数据结构和算法是紧密相关的，选择合适的数据结构可以大幅提升算法的效率，从而更快地解决问题。
4. **应对面试挑战：** 许多技术面试都会考察数据结构和算法的知识，掌握了这些知识可以帮助你在面试中更好地应对各种挑战。
5. **为工程实践打下基础：** 在实际的软件开发中，经常需要处理各种数据，了解不同的数据结构可以为你在工程实践中选择合适的工具提供指导。

掌握了数据结构与算法，你看待问题的深度，解决问题的角度就会完全不一样。因为这样的你，就像是站在巨人的肩膀上，拿着生存利器行走世界。数据结构与算法，会为你的编程之路，甚至人生之路打开一扇通往新世界的大门。

### 1.1.3 数据结构和算法的关系

数据结构和算法是密切相关的，它们之间有着互相依存的关系：

1. **数据结构为算法服务：** 数据结构提供了存储和组织数据的方式，为算法提供了操作数据的基础。选择合适的数据结构可以使得算法更加高效、简洁。
2. **算法作用于数据结构：** 算法是解决问题的方法和步骤，而这些问题通常涉及对数据的操作。算法通过对数据结构进行操作，实现了对数据的处理、查找、排序等功能。
3. **相辅相成：** 数据结构和算法相辅相成，优秀的算法需要建立在合适的数据结构之上，而高效的数据结构也需要结合适当的算法来实现其功能。
4. **优化效率：** 选择合适的数据结构可以优化算法的效率，而设计高效的算法也需要考虑数据结构的特点，以实现更快速、更节省资源的操作。

总的来说，数据结构和算法是计算机科学中的两大基础，它们相互促进、相互支撑，共同构建了解决问题的框架和方法。因此，我们无法孤立数据结构来讲算法，也无法孤立算法来讲数据结构。

## 1.2 数据结构

数据结构可以根据`逻辑结构`和`物理结构`进行分类：

1. **逻辑结构：**数据对象中数据元素之间的相互关系
   - **集合结构：**数据元素同属于一个集合，但是元素之间没有任何关系，这和数学中的集合类似。
   - **线性结构：** 线性结构是`数据元素之间存在一对一的逻辑关系`，包括数组、链表、栈和队列等。
     - **数组（Array）：** 数组是一种线性数据结构，它由相同类型的元素组成，并以连续的内存地址存储。`数组的特点是可以通过索引快速访问任何元素，但插入和删除操作可能会比较耗时`，需要移动其他元素。
     - **链表（Linked List）：** 链表也是一种线性数据结构，它由节点组成，每个节点包含数据和指向下一个节点的指针。`链表的特点是插入和删除操作效率较高，但访问元素需要从头节点开始逐个遍历`。
     - **栈（Stack）：** 栈是一种`后进先出（LIFO）`的数据结构，`只能在栈顶进行插入和删除操作`。栈通常用于实现函数调用、表达式求值等场景。
     - **队列（Queue）：** 队列是一种`先进先出（FIFO）`的数据结构，`只能在队尾插入元素，在队首删除元素`。队列通常用于实现任务调度、消息传递等场景。
   - **非线性结构：** 非线性结构是`数据元素之间存在一对多或多对多的逻辑关系`，包括树和图等。
     - **树（Tree）：** 树是一种非线性数据结构，它由节点组成，每个节点可以有零个或多个子节点。树的特点是可以用于表示层次关系，如文件系统、组织结构等。
     - **图（Graph）：** 图是一种非线性数据结构，它由节点（顶点）和边组成，用于表示元素之间的关系。图的特点是可以表示各种复杂的关联关系，如社交网络、网络拓扑等。
2. **物理结构：**数据在计算机中的存储形式
   - **顺序存储结构：** 顺序存储结构是指数据元素`在内存中占据一段连续的空间`，例如数组。
   - **链式存储结构：** 链式存储结构是指数据元素`在内存中非连续存储`，而是通过指针相互连接，例如链表。

`逻辑关系主要描述数据元素之间的逻辑连接方式，而物理关系描述数据元素在内存中的存储结构`。选择合适的逻辑关系和物理关系可以更好地组织和操作数据，在算法设计和实现时起到重要作用。

## 1.3 算法

### 1.3.1 算法的特性

算法具有5个基本特性：**输入**、**输出**、**有穷性**、**确定性**、**可行性**。

1. **输入输出**

   - 算法具有零个或多个输入，比如：键盘输出、参数等
   - 算法至少有一个或多个输出，比如：打印输出、返回值等

2. **有穷性**

   算法在执行有限的步骤后会自动结束，而不会出现死循环，并且每一个步骤都可以在可以接受的时间内完成。

3. **确定性**

   算法的每个步骤都有具体确定的含义，不会出现二义性。

4. **可行性**

   算法的每一个步骤都是可行的，也就是说，每一步都能够通过执行有限的次数完成。

### 1.3.2 算法的设计要求

在编写算法的时候，我们一般用什么标准来评判它的优劣呢？主要有三个方面：

1. **正确性**

   算法的正确性大体上可以分为四个层次：

   - 算法程序没有语法错误
   - 算法程序对于合法的输入数据，能够得到满足要求的输出结果
   - 算法程序对于非法的输入数据，能够产生满足规格说明的结果
   - 算法程序对于精心选择的，甚至刁难的测试数据都有满足要求的输出结果。

2. **可读性**

   写代码的目的，一方面是让计算机执行，还有另一个重要的目的就是便于他人阅读、理解和交流。

3. **健壮性**

   当输入的数据不合法时，算法也能够做出相应的处理，而不是产生异常或者莫名其妙的结果。

### 1.3.3 算法效率的度量方法

我们都知道，数据结构和算法本身解决的是 “快” 和 “省” 的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量编写的算法代码的执行效率呢？

算法效率的评估一般有两种方式：

#### 1.3.3.1 事后统计法

通过设计好的测试程序和数据，把代码跑一遍，通过统计、监控，就能得到算法执行的时间和占用的内存大小。最后对不同算法的运行结果进行比较，就能得到算法效率的高低了。

通过上述方式评估算法的执行效率肯定是正确的，但是，这种统计方法有非常大的局限性。

1. 测试结果非常依赖测试环境
   - 处理器性能不同得到的结果也不同，比如：i5和i7
   - 处理器指令集架构不同，对结果影响很大
     - **CISC（复杂指令集计算机）：**在硬件上提供了乘法器
     - **RISC（精简指令集计算机）：**通过加法指令来实现乘法指令
2. 测试结果受数据规模的影响很大
   - 量大 VS 量小
   - 无限接近有序的数据 VS 极度混乱的数据
3. 编写测试程序成本高
   - 花费大量精力编写的测试程序，但是测出的结果是算法效率很低，竹篮打水一场空

所以，我们需要一个`不用具体的测试数据来测试，就可以粗略地估计算法的执行效率的方法`。

#### 1.3.3.2 事前分析估算法

事前估算法就在程序编译之前，依据统计方法对算法进行估算。

具体的估算方法请看下一章节：

# 2、算法复杂度

我们都知道，数据结构和算法本身解决的是 “快” 和 “省” 的问题，即如何让代码运行得更快，如何让代码更省存储空间。所以，执行效率是算法一个非常重要的考量指标。那如何来衡量你编写的算法代码的执行效率呢？这里就要用到本章要讲的内容：时间、空间复杂度分析。

## 2.1 大O表示法

时间复杂度指的就是算法的执行效率，粗略地讲，就是算法代码执行的时间，用时越短效率越高。但是，如何在不运行代码的情况下，用“肉眼”得到一段代码的执行时间呢？

先看一段简单的代码：

```c++
void func(int n) 
{ 
    int sum = 0; 
    for (int i=1; i <= n; ++i) 
    { 
        sum = sum + i; 
    } 
    printf("sum = %d\n", sum); 
}
```

从 CPU 的角度来看，执行每行代码的操作都类似，虽然执行时间不尽相同，但是可以假设 CPU 执行每行代码的时间都是一个指令周期，这样就可以轻松算出上面代码的执行时间了：

- 第 3、8 行，分别需要1个指令周期 -> 2
- 第 4、6 行，分别需要n个指令周期 -> 2n

所以上面代码评估出的执行总时间是：**T(n) = 2n+2**

按照这个分析思路，我们再来分析一下这段代码：

```c++
void func1(int n) 
{
    int sum = 0;
    for (int i = 1; i <= n; ++i) 
    {
        printf("i = %d\n", i);
        for (int j=1; j <= n; ++j) 
        {
            printf("j = %d\n", j);
            sum = sum + i + j;
        }
    }
    printf("sum = %d\n", sum);
}
```

- 第 3、13 行，分别需要1个指令周期 -> 2
- 第 4、6 行，分别需要n个指令周期 -> 2n
- 第 7、9、10 行，分别需要n2个指令周期 -> 3n^2^

所以上面代码评估出的执行总时间是：**T(n) = 3n^2^+2n+2**

在数据结构中针对于复杂度的描述有一个表示方法，叫做**大 O（欧）表示法**，公式如下：

> **==T(n) = O(f(n))==**

- T(n) 表示代码执行的时间；
- n 表示数据规模的大小；
- f(n) 表示每行代码执行的次数总和；
- O 表示代码的执行时间 T(n) 与 f(n) 表达式成正比；

所以上面估算出的代码复杂度用大O表示法可以写成这样：

- T(n) = O(2n+2)
- T(n) = O(3n2+2n+2)

**大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势**，所以也叫作**==渐进时间复杂度==**，简称**==时间复杂度==**。

当 n 很大时，你可以把它想象成非常非常非常大的数，此时公式中的`低阶、常量、系数`三部分并不左右增长趋势，所以都可以忽略。我们只需要记录一个最大量级就可以了，如果用大 O 表示法表示上面两段代码的时间复杂度，就可以记为：T(n) = O(n)； T(n) = O(n2)。

关于时间复杂度的推导，有以下**==三条原则==**可供参考：

1. **只关注一个代码块中循环执行次数最多的一段代码**
2. **加法法则：多个代码块的总复杂度等于量级最大的那段代码的复杂度**
3. **乘法法则：嵌套代码的复杂度等于嵌套内外代码复杂度的乘积**

## 2.2 时间复杂度分析

### 2.2.1 O(1)

`O(1) `只是`常量级`时间复杂度的一种表示方法，并不是指只执行了一行代码。比如下面代码，即便有多行，它的时间复杂度也是 O(1）。

```c++
#include <stdio.h>
int findMax(int a, int b) 
{
    return (a > b) ? a : b;
}

int findMin(int a, int b) 
{
    return (a < b) ? a : b;
}

int main() 
{
    int num1 = 10, num2 = 20;    
    printf("最大值是：%d\n", findMax(num1, num2));
    printf("最小值是：%d\n", findMin(num1, num2));
    return 0;
}
```

一般情况下，**==只要算法中不存在循环语句、递归语句，即使有成千上万行的代码，其时间复杂度也是Ο(1)==**。

### 2.2.2 O(logn)、O(nlogn)

关于数阶形式的时间复杂度也非常常见，同时也是最难分析的一种时间复杂度。下面举例说明：

```c++
#include <stdio.h>
int loopFunction(int n) 
{
    int i = 1;
    int count = 0;    // 用于记录循环执行的次数
    while (i <= n) 
    {
        i = i * 2;
        count++;      // 每次循环执行都增加计数
    }
    return count;
}

int main() 
{
    int n = 100;
    int result = loopFunction(n);
    printf("循环执行了 %d 次\n", result);
    return 0;
}
```

在这个`while`循环中，`i` 的初始值为 1，每次循环 `i` 都会乘以 2，直到 `i` 的值超过 `n` 为止。

[![img](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/9b1c88264e7a1a20b5954be9bc4bec9a.jpg)](https://subingwen.cn/data-structure/complexity/9b1c88264e7a1a20b5954be9bc4bec9a.jpg)

分析这段代码的难度在于`while`并不是循环了`n`次，循环执行的次数取决于将 1 乘以多少次 2 后会超过 `n`。所以最后一次循环应该是 **2^x^>=n**，指数`x`就是循环的次数，求指数`x`的表达式可以写为： **x=log~2~n**，所以代码的时间复杂度为 **O(log~2~n)**

如果将上面的代码稍作修改:

```c++
int loopFunction(int n) 
{
    int i = 1;
    int count = 0;    // 用于记录循环执行的次数
    while (i <= n) 
    {
        i = i * 3;
        count++;      // 每次循环执行都增加计数
    }
    return count;
}
```

按照刚才的思路其分析，最后一次循环应该是 3^x^>=n，因此 x=log3n ，所以这个函数的时间复杂度为 O(log~3~n)

实际上，**不管是以 2 为底、以 3 为底，还是以 10 为底，我们可以把所有对数阶的时间复杂度都记为 O(logn)**。为什么呢？下面给大家推导一下：

> 1. **根据换底公式，将以3为底的对数转换为以2为底的对数**
>
>    ==**log~3~N = log~2~N / log~2~3**==
>
> 2. **将分母移动到等号左边**
>
>    ==**log~3~N * log~2~3 = log~2~N**==
>
> 3. **两边同乘 log~3~2**
>
>    ==**log~3~N * log~2~3 * log~3~2 = log~2~N * log~3~2**==
>
> 4. **因为log~2~3 * log~3~2 = 1**
>
>    ==**log~3~N = log~2~N * log~3~2**==

由于log~3~2是常数，根据大O表示法规则，低阶、常量、系数三部分可以忽略，所以 O(log~3~N) = O(log~2~N)，如果只看第一步 1/log~2~3 也是一个常数，将其忽略之后也可以得出 O(log~3~N) = O(log~2~N)

使用同样的方法进行推导可得到结论：

> **==O(log~3~N) = O(log~2~N) = O(logN) 【O(log~10~N) = O(logN)】==**

这样我们就能彻底明白为什么所有的对数阶都用以10为底的对数来表示了。

如果把上面的`main`函数修改为下面的样子，程序的时间复杂度就又变了:

```c++
int main() 
{
    int n = 100;
    for(int i=0; i<n; ++i)
    {
        int result = loopFunction(n);
        printf("循环执行了 %d 次\n", result);
    }
    return 0;
}
```

由于`loopFunction`函数的时间复杂度为`O(logn)`，又因为该函数需要在一个循环中执行n次，所以该`main`函数的时间复杂度为`O(nlogn)`

### 2.2.3 O(m+n)、O(m*n)

我们再来讲一种跟前面都不一样的时间复杂度，代码的复杂度由两个数据的规模来决定。先看代码：

```c++
int calc(int m, int n) 
{
    int sum1 = 0;
    for (int i=1; i < m; ++i) 
    {
        sum1 = sum1 + i;
    }

    int sum2 = 0;
    for (int j=1; j < n; ++j) 
    {
        sum2 = sum2 + j;
    }
    return sum1 + sum2;
}
```

从代码中可以看出，`m` 和 `n` 是表示两个数据规模。我们无法事先评估 m 和 n 谁的量级大，所以我们在表示复杂度的时候，就不能简单地利用加法法则，省略掉其中一个。所以，上面代码的时间复杂度就是` O(m+n)`。

如果将上面的两个并列的`for`循环写成如下的嵌套的形式，此时时间复杂度就变成了`O(m*n)`。

```c++
int calc(int m, int n) 
{
    int sum1 = 0;
    int sum2 = 0;
    for (int i=1; i < m; ++i) 
    {
        for (int j=1; j < n; ++j) 
        {
            sum2 = sum2 + j;
        }
        sum1 = sum1 + sum2 + i;
    }
    return sum1;
}
```

### 2.2.4 O(n^2^)

如果有一个嵌套的循环，并且外层和内层的循环次数是相同的，此时这段程序的时间复杂度就是 **O(n^2^**)，比如：

```c++
void func1(int n) 
{
    int sum = 0;
    for (int i = 1; i <= n; ++i) 
    {
        printf("i = %d\n", i);
        for (int j=1; j <= n; ++j) 
        {
            printf("j = %d\n", j);
            sum = sum + i + j;
        }
    }
    printf("sum = %d\n", sum);
}
```

但是不是所有嵌套循环内外的循环次数都相等，比如下面这样：

```c++
void func2(int n)
{
    int sum = 0;
    for (int i = 1; i <= n; ++i)
    {
        printf("i = %d\n", i);
        for (int j = i; j <= n; ++j)  // 此处是 j=i, 不是 j=0
        {
            printf("j = %d\n", j);
            sum = sum + i + j;
        }
    }
    printf("sum = %d\n", sum);
}
```

- 当 i=0 时，内层循环执行了 n 次
- 当 i=1 时，内层循环执行了 n-1 次
- 当 i=2 时，内层循环执行了 n-2 次
- ……
- 当 i=n 时，内层循环执行了 1 次

所以执行的总次数为：**n+(n-1)+(n-2)+…+1 = n(n+1)/2 = n^2^/2+n/2**

根据大O表示法推导规则，去掉系数和低阶之后得到的复杂度为 **O(n^2^)**

## 2.3 空间复杂度

**空间复杂度**是对算法在运行过程中所需存储空间大小的评估。使用大O表示法既可以描述时间复杂度也可以用来描述空间复杂度。

下面拿一段代码举例：

```c++
#include <iostream>
int main() 
{
    int size;
    std::cout << "请输入数组大小: ";
    std::cin >> size;
    // 使用 new 运算符为数组动态分配内存
    int *arr = new int[size];
    // 使用分配的内存存储数据
    for (int i = 0; i < size; ++i) {
        arr[i] = i * 2; // 以偶数填充数组
    }
    // 打印数组内容
    std::cout << "数组内容: ";
    for (int i = 0; i < size; ++i) {
        std::cout << arr[i] << " ";
    }
    std::cout << std::endl;
    // 记得释放内存
    delete[] arr;
    return 0;
}
```

在上面代码中，第4行、10行、15行各自定义了一个整形变量，它们都是常数阶的空间复杂度记作`O(3*4)`，在第8行定义了一个整形数组，空间复杂度为`O(4n)`，总的复杂度使用加法法则记作`O(4n+12)`，在忽略到常数和系数之后空间复杂度记作`O(n)`

我们常见的空间复杂度就是 O(1)、O(n)、O(n2)，像 `O(logn)`、`O(nlogn)` 这样的对数阶复杂度平时都用不到。而且，空间复杂度分析比时间复杂度分析要简单很多。

## 2.4 复杂度量级

虽然代码千差万别，但是常见的复杂度量级并不多。主要有:

| 常量阶     | O(1)     |
| ---------- | -------- |
| 对数阶     | O(logn)  |
| 线性阶     | O(n)     |
| 线性对数阶 | O(nlogn) |
| 平方阶     | O(n^2^)  |
| 立方阶     | O(n^3^)  |
| k次方阶    | O(n^k^)  |
| 指数阶     | O(2^n^)  |
| 阶乘阶     | O(n!)    |

常见的时间复杂度所耗费的时间从小到大依次为：

> **==O(1) < O(logn) < O(n) < O(nlogn) < O(n2) < O(n3) < O(2n) < O(n!)==**

[![image-20240511215830720](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240511215830720.png)](https://subingwen.cn/data-structure/complexity/image-20240511215830720.png)

# 3、线性表之数组

数组（Array）是 C/C++ 中最基础和重要的数据结构之一，它提供了一种有效存储和访问固定大小元素集合的方式。关于数组的定义和使用相信大家都已经熟练掌握，本文将着重为大家剖析数组的物理结构和逻辑结构。

## 3.1 数组的物理结构

数组的物理结构是指数组元素在内存中的实际存储方式。在内存中，数组元素是连续存储的，这意味着相邻元素的地址是连续的，且每个元素占用固定大小的内存空间。

例如，对于一个整型数组 `int numbers[5]`，如果数组的起始地址为 `0x1000`，每个整型元素占据4个字节，那么数组中的元素在内存中的存储情况可能如下：

```c++
0x1000: numbers[0]
0x1004: numbers[1]
0x1008: numbers[2]
0x100C: numbers[3]
0x1010: numbers[4]
```

[![image-20240617165658960](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240617165658960.png)](https://subingwen.cn/data-structure/array/image-20240617165658960.png)

这样的存储方式保证了对数组元素的快速访问和遍历，因为可以通过计算地址偏移来访问数组中的任意元素。

## 3.2 数组的逻辑结构

### 3.2.1 线性表

数组是一种线性数据结构，它由相同类型的元素组成，并以连续的内存地址存储。所谓的`线性表就是由一个或多个元素组成的有序序列`。在一个线性表中头部节点只有一个后继节点，尾部节点只有一个前驱节点，头部和尾部中间的节点分别有一个前驱节点，一个后继节点，如下图：

[![image-20240617170757242](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240617170757242.png)](https://subingwen.cn/data-structure/array/image-20240617170757242.png)

根据从前到后的顺序，我们就可以将A1记作头结点，A5记作尾节点，A2~A4记作中间节点。拿A3举例，它的前驱节点是A2，后继节点是A4。

在逻辑上，数组是一个有序集合，每个元素可以通过唯一的下标（索引）来访问。

例如，数组 `int numbers[5]` 中的元素可以用 `numbers[0]`、`numbers[1]`、`numbers[2]`、`numbers[3]` 和 `numbers[4]` 这些下标来访问。这种抽象方式隐藏了数组元素在内存中的实际存储方式，使程序员只需关注元素的逻辑位置而无需担心其物理存储。

### 3.2.2 数组的优缺点

关于数组的使用，它的优缺点总结如下：

- 优点
  - 通过下标访问数组中的任意元素速度非常快，时间复杂度是 O(1)
  - 末尾位置增加、删除元素速度非常快，时间复杂度是O(1)
  - 访问当前元素前、后相邻位置的元素非常方便
- 缺点
  - 非末尾位置增加、删除元素需要进行大量的数据移动，时间复杂度为 O(n)
  - 搜索效率比较低，时间复杂度
    - 无序数组 - 线性搜索 O(n)
    - 有序数组 - 二分搜索O(logn)
  - 数组扩容的时候资源开销比较大

## 2.3 动态数组

在C语言中是没有动态数组的概念的，只有静态数组。想要使用动态数组只能由程序员自己实现，其核心思想有以下几点：

1. 记录下数组的容量和数组中存储的数据的个数
2. 当数组的容量 == 存储的数据个数的时候重新申请一块新内存或者扩容

1. - 可以使用[realloc（函数位于第3章）](https://subingwen.cn/c/memory-layout/)对数组进行扩容
   - 可以使用`new`或者`malloc`重新申请一块更大的内存，然后再将旧数据拷贝到新内存中，最后释放旧的内存资源

与此同时，如果要求这个动态数组可以在不同场景下存储不同类型的数据，我们就需要使用泛型编程，因此可以这样定义这个类:

```c++
#include <iostream>
using namespace std;

template <typename T>
class Array
{
public:
    Array(int size = 64);
    ~Array();

    // 在尾部添加元素
    void append(T val);
    // 尾部删除元素
    void popBack();
    // 插入元素
    void insert(int pos, T val);
    // 删除元素
    void remove(int pos);
    // 查询元素-> 返回位置
    int find(T val);
    // 得到指定位置的元素的值
    int value(int pos);
    // 获取数组元素数量
    int size();
    // 打印数据
    void show();
private:
    void expand(int size);
private:
    T* m_arry;           // 数组的起始地址
    int m_capacity;      // 数组容量
    int m_count;         // 数组中的元素数量
};
```

在编写模板类的时候需要注意一个问题：类的声明和定义要写到同一个文件中，如果分开写到 .h 和 .cpp 中，编译的时候就会出现链接错误。因此在实现上边这个的类的时候可以将代码写到一个 .h 或者 .hpp 文件中。

**array.hpp 文件**

```c++
#include <iostream>
#include <cassert>
using namespace std;

template <typename T>
class Array
{
public:
    Array(int size = 64);
    ~Array();

    // 在尾部添加元素
    void append(T val);
    // 尾部删除元素
    void popBack();
    // 插入元素
    void insert(int pos, T val);
    // 删除元素
    void remove(int pos);
    // 查询元素-> 返回位置
    int find(T val);
    // 得到指定位置的元素的值
    int value(int pos);
    // 获取数组元素数量
    int size();
    // 打印数据
    void show();

private:
    void expand(int size);

private:
    T* m_arry;           // 数组的起始地址
    int m_capacity;      // 数组容量
    int m_count;         // 数组中的元素数量
};

template <typename T>
Array<T>::Array(int size) :
    m_capacity(size),
    m_count(0),
    m_arry(new T[size]()) 
{
}

template <typename T>
Array<T>::~Array()
{
    // 释放资源
    delete[]m_arry;
    m_arry = nullptr;
}

template <typename T>
void Array<T>::append(T val)
{
    // 满了, 扩容
    if (m_count == m_capacity)
    {
        expand(m_capacity * 2);
    }
    m_arry[m_count++] = val;
}

template <typename T>
void Array<T>::popBack()
{
    if (m_count == 0)
    {
        return;
    }
    m_count--;  // 把尾部元素变成了无效元素
}

template <typename T>
void Array<T>::insert(int pos, T val)
{
    if (pos < 0 || pos > m_count) 
    {
        cout << "插入数据失败: 无效的pos位置" << endl;
        return;
    }
    if (m_count == m_capacity)
    {
        expand(2 * m_capacity);
    }
    // 移动元素
    for (int i = m_count - 1; i >= pos; --i)
    {
        m_arry[i + 1] = m_arry[i];
    }
    m_arry[pos] = val;
    m_count++;
}

template <typename T>
void Array<T>::remove(int pos)
{
    if (pos < 0 || pos >= m_count)  
    {
        return;
    }
    int value = m_arry[pos];
    for (int i = pos + 1; i < m_count; ++i)
    {
        m_arry[i - 1] = m_arry[i];
    }
    m_count--;
}

template <typename T>
int Array<T>::find(T val)
{
    for (int i = 0; i < m_count; ++i)
    {
        if (m_arry[i] == val)
        {
            return i;
        }
    }
    return -1;
}

template<typename T>
int Array<T>::value(int pos)
{
    assert(pos >= 0 && pos < m_count);
    return m_arry[pos];
}

template<typename T>
int Array<T>::size()
{
    return m_count;
}

template <typename T>
void Array<T>::show()
{
    for (int i = 0; i < m_count; ++i)
    {
        cout << m_arry[i] << " ";
        cout << (int)m_arry[i] << " ";
    }
    cout << endl;
}

template <typename T>
void Array<T>::expand(int size)
{
    // 申请一块新的内存
    T* ptr = new T[size]();
    // 旧数据拷贝到新内存
    memcpy(ptr, m_arry, sizeof(T) * m_capacity);
    delete[]m_arry;
    // 数据更新
    m_arry = ptr;
    m_capacity = size;
}
```

上面的代码是通过`append`或者`insert`函数往数组中添加数据的时候，判断了数组中已存储的元素数量，如果数组已满便调用`expand`函数进行扩容。

- 使用`relloc`函数扩容比重新分配内存的方式要简单一些，如果它在其它位置开辟了新的存储空间而不是在尾部扩容，会自动释放旧的内存块。
- 对数组进行动态扩容之后，要对数组的容量进行更新。
- 对数组进行动态扩容之后，要更新数组指针指向的起始地址。

另外，通过阅读上述代码也可以证明在数组的中间位置添加、删除数据都会涉及到元素的大量移动（后移或者前移），操作相率相对较低。

## 3.3 案例

数组作为 C/C++ 程序员密不可分的战友，其重要性在此不再过多赘述，下面有两个算法题，大家来一起练练手。

### 3.3.1 元素逆序

> 将数组中的所有元素首尾调换位置，假设数组中有N个元素：
>
> - 0号 和 N-1 号 元素调换位置
> - 1号 和 N-2 号 元素调换位置
> - 2号 和 N-3 号 元素调换位置
> - ……
>
> 比如原始序列为：1、2、3、4、5、6、7、8、9
>
> 处理完之后的序列应该为：9、8、7、6、5、4、3、2、1

要解决这个问题需要使用辅助指针，因为是需要交换数组中前后元素的位置，所以辅助指针需要两个，一个从数组头部开始，一个从数组尾部开始：

- 数组头部元素位置的下标为：0
- 数组尾部的元素位置的下标为：数组元素数量 - 1

两个辅助指针同时移动，这样当两个指针相遇的时候，数组中所有元素的交换也就完成了，如下图：

[![image-20240619223335409](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240619223335409.png)](https://subingwen.cn/data-structure/array/image-20240619223335409.png)

根据上面的分析，可以在前面的`Array`模板类中添加一个反转函数:

```c++
template<typename T>
void Array<T>::reverse()
{
    T* p = m_arry;                  // 头部
    T* q = m_arry + m_count - 1;    // 尾部
    while (p < q)
    {
        T tmp = *p;
        *p = *q;
        *q = tmp;
        p++;
        q--;
    }
}
```

**处理该问题的核心思想就是使用双辅助指针，然后同时移动这两个指针，并完成元素的交换，这样就可事半功倍**。

### 3.3.2 奇偶调整

> 将一个整形数组中的数据进行调整：
>
> - 把所有的奇数放到数组的左侧
> - 把所有的偶数放到数组的右侧

这个题目可以理解为是上个题目的升级版，我们来说具体分析一下：

- 奇数和偶数需要分别放在数组的两侧，所以需要的辅助指针有两个
- 两个指针一前一后各自对指向的当前元素进行奇偶判断，常用的判断奇偶的方式有两种：
  - 对数据进行`number%2`操作，结果为0是偶数，否则是奇数
  - 对数据进行`number&1` 操作，结果为0是偶数，否则是奇数
- 循环执行第二步，当找到了不满足条件的元素之后，交换前后两个指针指向的元素的值
- 当前后两个指针相遇的时候，数组中的数据调整完毕。

根据上面的分析，还是在`Array`模板类中添加一个处理函数：

```c++
template<typename T>
void Array<T>::adjust()
{
    T* p = m_arry;                  // 头部
    T* q = m_arry + m_count - 1;    // 尾部
    while (p < q)
    {
        while (p < q) 
        {
            if ((*p & 1) == 0)
            {
                break;
            }
            p++;
        }
        while (p < q)
        {
            if ((*q & 1) == 1)
            {
                break;
            }
            q--;
        }
        // 数据交换
        if (p < q)
        {
            T tmp = *p;
            *p = *q;
            *q = tmp;
            p++;
            q--;
        }
    }
}
```

- 第 6 行的 `while (p < q)`循环表示前后奇偶数交换还未完成，继续对数组进行遍历
- 第 8 行的 `while (p < q)`循环表示如果当前元素是奇数，当前指针继续后移
- 第 16 行的 `while (p < q)`循环表示如果当前元素是偶数，当前指针继续前移
- 第 10 行的`if ((*p & 1) == 0)`判断表示在数组前半部分找到了偶数
- 第 18 行的`if ((*q & 1) == 1)`判断表示在数组后半部分找到了奇数

# 4、线性表之静态链表

## 4.1 静态链表的设计

### 4.1.1 定义静态链表

链表是由多个相同类型的节点组成的线性表，它的每个节点都包含一个数据项和一个指向下一个节点的指针，链表中各个节点的地址是不连续的。

下面是一个用于存储整形数据的链表节点结构：

```c++
struct Node
{
    int data; 
    struct Node* next;
};
```

- `data`：用于存储实际数据
- `next`：用于连接当前节点的后继节点，存储的是下一个节点的地址（很多资料中将其称之为`游标`）

`静态链表是一种使用数组实现的链表`，通常用于环境中无法使用指针的情况。这种结构在内存中是连续存储的，但节点的位置可以变化，因此称为静态链表。

静态链表的节点结构和链表类似，但是不完全相同，当前节点连接后继节点使用的是索引而不是指针。

下面是一个用于存储整形数据的链表节点结构：

```c++
struct Node
{
    int data;
    int next; 
};
```

- `data`：用于存储实际数据
- `next`：使用索引的方式记录后继节点的位置

由于静态链表是一个数组，也就是说在存储数据之前元素对应的存储空间就已经存在了，此时我们就需要考虑以下几个问题：

1. 如何判断当前节点是一个空闲节点？
2. 如何判断当前节点是一个有效的数据节点？
3. 如何判断当前节点是链表的尾节点？

由于链表的数据域`data`的值是千变万化的，所以我们只能在它的`next`域上下功夫，在使用静态链表之前可以对它的值做如下规定（不考虑头结点）：

- `next == -1`：当前节点为静态链表的尾节点
- `next == -2`：当前节点为静态链表的空闲节点
- `next >= 0`：当前节点为静态链表的有效的数据节点

### 4.1.2 链表头结点

不论是链表（动态）还是静态链表根据处理方式的不同，都可以分为两大类：`带头结点`的链表和`不带头结点`的链表。

- `带头结点`：链表的第一个节点（头结点）的`data`域`不存储`数据，`next`域记录的是第一个数据节点的位置（索引或者地址）
- `不带头结点`：链表的第一个节点的`data`域`存储`数据，`next`域记录的是第二个数据节点的位置（索引或者地址）

一般情况下建议大家使用带头结点的链表，带头结点的链表避免了链表中没有节点的这种情况（空链表指的是链表中没有数据节点），减少了bug的产生，并且更容易处理和维护。

下图描述的是一个静态链表，请大家动脑分析，完成对这个链表的遍历。

[![image-20240620103247996](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240620103247996.png)](https://subingwen.cn/data-structure/static-list/image-20240620103247996.png)

虽然数组中存储的数据的按照下边遍历顺序为：`null、a、b、c、f、d、g`，但实际上在静态链表中存储的数据顺序并非如此。其中的关键点就是：先看各个节点中的 next 域记录的位置，然后再把这个位置作为数组的下标，去访问对应的数组元素。

- 数组0号元素为静态链表的头结点，`next=6`，所以第1个数据为`g`
- 数组6号元素为静态链表的数据节点，`next=1`，所以第2个数据节点为`a`
- 数组1号元素为静态链表的数据节点，`next=5`，所以第3个数据节点为`d`
- 数组5号元素为静态链表的数据节点，`next=4`，所以第4个数据节点为`f`
- 数组4号元素为静态链表的数据节点，`next=2`，所以第5个数据节点为`b`
- 数组2号元素为静态链表的数据节点，`next=3`，所以第6个数据节点为`c`
- 数组3号元素为静态链表的尾节点，没有后继节点

因此遍历静态链表，得到的序列应该是：`g、a、d、f、b、c`

## 4.2 静态链表的操作

> 以下操作的都是带头结点的静态链表，它的第一个数据节点记作 pos=0

### 4.2.1 遍历和搜索

关于静态链表中数据搜索，搜索的是节点的值，而不是它的位置。在搜索的时候需要分两步走：

1. 根据链表节点的`next`域，从前往后依次访问各个节点
2. 取出当前节点的`data`值，和要搜索的值进行比较
   - 相等：节点找到了，使用`break`或者`return`终止循环
   - 不相等：没找到需要的节点，继续向下遍历

> 下图描述的就是遍历静态数组的整个过程：
>
> - 通过头结点的`next`域记录的值找到第一个数据节点的位置
> - 通过第1个数据节点的`next`域记录的值找到第2个数据节点的位置
> - 通过第2个数据节点的`next`域记录的值找到第3个数据节点的位置
> - ……
> - 如果节点的`next`域值为`-1`，表示当前节点是最后一个数据节点，静态链表遍历结束。

[![image-20240621174054059](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240621174054059.png)](https://subingwen.cn/data-structure/static-list/image-20240621174054059.png)

> 上面的这个图乍一看乱糟糟，其实一点不乱，根据箭头的方向就能完成整个静态链表的遍历了。
>
> 掌握了静态链表的遍历，关于节点的搜索就非常简单了，只需要在遍历过程中再进行一次判断即可，在此就不再过多赘述了。

### 4.2.2 数据的插入

因为链表是线性表，在链表中插入数据的时候一般都是根据位置进行操作，添加节点有三种方式：

1. 在链表的头部添加新节点
2. 在链表的尾部添加新节点
3. 在链表的中间位置添加新节点

在链表头部和尾部添加节点的操作都相对比较简单，因为我们可以将它们和插入合并到一起，也就是此处讲的插入节点的操作是`在链表的任意位置插入新的节点`。

下面带大家一起分析一下在静态链表中插入数据的具体流程：

1. 判断要插入的数据的位置，有效范围应该是：`0 <= pos <=length` 
   - `pos==0` 新节点作为链表的第一个数据节点
   - `pos==length` 新节点添加到链表的尾部
   - `0 < pos < length` 新节点插入到`pos`位置之前
2. 遍历数组，找到一个没有存储数据的空闲节点，记作`freeNode` 
   - 条件为：`next == -2`
3. 判断静态链表是否满了，如果满了可以选择扩容或者拒绝插入数据
4. 根据静态链表节点的`next`域遍历链表，找到`pos-1`位置的节点, 记作`curNode`
5. 节点赋值并调整位置
   - 给`freeNode` 节点赋值
   - 将`freeNode`的后继节点设置为`pos`节点，该节点的索引值是存储在`curNode.next`里边的
   - 将`curNode`节点的后继节点设置为`freeNode`

> 下图是是一个静态链表，链表中的元素依次是：`a->d->f->b->c`

[[![image-20240621170532076](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240621170532076.png)](https://subingwen.cn/data-structure/static-list/image-20240621170532076.png)
](https://subingwen.cn/data-structure/static-list/image-20240621170532076.png)

> 现在要求在静态链表的`第三个节点`位置插入新的元素 `g`，也就是说插入成功之后`g`就变成了第三个数据节点，原来的第三个数据节点变成了第四个数据节点。

1. 首先需要根据链表节点的`next`域遍历链表，找到第三个节点的上一个节点，即第二个数据节点。

   - 根据头结点的`next`域找到的第一个数据节点为`1号位置的节点`

   - 根据1号位置节点的`next`域找到的第二个数据节点为`5号位置的节点`

     [![image-20240621170552250](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240621170552250.png)](https://subingwen.cn/data-structure/static-list/image-20240621170552250.png)

2. 给6号位置节点初始化为`g`，将它的后继设置为`5号节点的后继（该节点为原来的第三个数据节点）`

3. 更新第二个数据节点的后继，让6号位置节点作为链表的第三个数据节点，也就是让`五号位置节点的 next = 6`

   ![image-20240621170610673](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240621170610673.png)

> 再次遍历这个静态链表，节点值依次为：`a->d->g->f->b->c`

到此为止新节点的插入操作就完成了。

### 4.2.3 数据的删除

删除静态链表中的元素，通常情况下还是根据位置来进行操作，操作步骤如下：

1. 判断要删除的数据的位置，有效范围应该是：`0 <= pos <length` 
   - `pos==0` 删除的是第一个数据节点
   - `pos==length-1` 删除的是尾部最后一个数据节点
   - `0 < pos < length-1` 删除的是`pos`位置的数据节点
2. 遍历静态链表，找到`pos-1`位置的节点，记作`curNode`
3. 根据`curNode`找到要是删除的节点`delNode` ，它的位置 = `curNode.next`
4. 链表节点重新连接`curNode.next = delNode.next`
5. 将已删除节点`delNode`的`next`域标记为未使用，即`delNode.next=2`

> 接下来再通过图表的方式为大家举例说明，看下图，要求`删除静态链表中的第二个数据节点`，第二个数据节点也就是数组5号位置的节点，因为遍历链表节点的顺序为：`a->d->f->b->c`

[![image-20240621170629549](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240621170629549.png)](https://subingwen.cn/data-structure/static-list/image-20240621170629549.png)

> 遍历这个静态链表，找到第一个数据节点（要删除位置的节点的前驱）

[![image-20240621171200814](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240621171200814.png)](https://subingwen.cn/data-structure/static-list/image-20240621171200814.png)

> 重新进行链表节点的连接：`第一个数据节点的后继 = 要删除的节点的后继`，通过这个操作就从静态链表中删除了原来的第二个数据节点。

[![image-20240621171833975](%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%9C%E4%B8%8E%E7%AE%97%E6%B3%95.assets/image-20240621171833975.png)](https://subingwen.cn/data-structure/static-list/image-20240621171833975.png)

> 再次遍历这个静态链表，得到的节点顺序应该是：`a->f->b->c`。为了能够复用数组5号位置的元素，根据规则需要将它的`next`域修改为`-2`

## 4.3 示例代码

### 4.3.1 头文件

**StaticLinkList.h**

```c++
#pragma once
#include <iostream>
using namespace std;


struct Node
{
    int data;
    int next; 
};

// 静态链表列
class SLinkList
{
public:
    SLinkList(int size);
    ~SLinkList();
    // 插入元素, 把数据放到某个元素之前
    bool insert(int pos, int data);
    // 删除元素
    void remove(int pos);
    // 查找元素, 返回位置
    int find(int data);
    // 遍历元素
    void display();
private:
    Node* m_list = nullptr;
    int m_size;      // 链表的容量
    int m_length;    // 元素数量
};
```

### 4.3.2 源文件

**StaticLinkList.cpp**

```c++
#include "StaticLinkList.h"

SLinkList::SLinkList(int size) : 
    m_size(size),
    m_length(0),
    m_list(new Node[size])
{
    m_list[0].next = -1;    
    for (int i = 1; i < size; ++i)
    {
        m_list[i].next = -2;
    }
}

SLinkList::~SLinkList()
{
    if (m_list)
    {
        delete[]m_list;
        m_list = nullptr;
    }
}

bool SLinkList::insert(int pos, int data)
{
    if (pos < 0 || pos > m_size)
    {
        cout << "插入的位置不合法!" << endl;
        return false;
    }

    int index = -1; 
    for (int i = 1; i < m_size; ++i)
    {
        if (m_list[i].next == -2)
        {
            index = i;
            break;
        }
    }
    if (index == -1)
    {
        cout << "链表已满, 无法插入新数据" << endl;
        return false;
    }

    int current = 0;   
    int count = 0;
    while (m_list[current].next != -1 && count < pos)
    {
        current = m_list[current].next;
        count++;
    }

    m_list[index].data = data;
    m_list[index].next = m_list[current].next;  
    m_list[current].next = index; 
    m_length++;
    return true;
}

void SLinkList::remove(int pos)
{
    if (pos < 0 || pos >= m_length)
    {
        cout << "删除的位置的不合法" << endl;
        return;
    }
    int current = 0; 
    int count = 0; 
    while (m_list[current].next != -1 && count < pos)
    {
        current = m_list[current].next;
        count++;
    }

    int delPos = m_list[current].next;
    m_list[current].next = m_list[delPos].next;
    m_list[delPos].data = 0;
    m_list[delPos].next = -2;
    m_length--;
}

int SLinkList::find(int data)
{
    int current = m_list[0].next;
    int pos = 0;
    while (current != -1)
    {
        if (data == m_list[current].data)
        {
            return pos;
        }
        current = m_list[current].next;
        pos++;
    }
    return -1;
}

void SLinkList::display()
{
    if (m_list[0].next == -1)
    {
        cout << "当前链表是一个空链表" << endl;
        return;
    }
    int current = m_list[0].next;
    while (current != -1)
    {
        cout << m_list[current].data << " ";
        current = m_list[current].next;
    }
    cout << endl;
}

int main()
{
    SLinkList ls(30);
    ls.insert(0, 10);
    ls.insert(0, 100);
    ls.insert(1, 30); 
    ls.insert(1, 33);
    ls.insert(2, 66);
    ls.insert(5, 88);
    ls.insert(6, 99);
    ls.display();

    ls.remove(0);
    ls.display();
    ls.remove(5);
    ls.remove(1);
    ls.display();

    int pos = ls.find(88);
    cout << "pos = " << pos << endl;

    return 0;
}
```

程序输出的结果为：

```c++
100 33 66 30 10 88 99
33 66 30 10 88 99
33 30 10 88
pos = 3
```

在上面的示例程序中，使用的是一个静态数组，当可用空间用完之后就拒绝再次往静态链表中添加数据了。当然，也可以将这个数组修改为动态数组，这样这样静态链表也就没有了最大存储上限。关于[如何实现一个动态数组](https://subingwen.cn/data-structure/array/)在上一节中已经做了详细讲解，大家可以自行考古。

## 4.4 静态链表和数组

静态链表和数组的本质是相同的，但是在使用方式上又有所不同，下面就给大家总结一下二者的优缺点：

1. 插入删除操作，静态链表效率高
   - 静态链表只需要修改对应节点的`next`域的值，需不要移动元素
   - 数组在插入新节点需要大量元素后移，删除节点需要大量元素前移
2. 访问指定位置的元素，数组效率高
   - 静态链表需要遍历才能找到这个节点
   - 数组通过下标就可以找到该节点了
3. 默认情况下内存大小是固定的
   - 申请的内存空间大，但是数据量少，浪费存储空间
   - 申请的内存空间小，但是数据量大，内存不够用

静态链表和数组是对同一块连续内存的两种不同使用方式，二者没有孰优孰劣之分，作为一名合格的程序猿要做的就是具体问题具体分析，从众多解决方案中找出一个最优解。



















































































































































































































































































































































































































































































































































































































































